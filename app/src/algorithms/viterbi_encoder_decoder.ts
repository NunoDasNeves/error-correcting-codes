
// convert a regular string to an array of bits for use with an Encoder
export function stringToBinaryArray(s: string): number[] {
  const ret: number[] = []

  for(let i = 0; i < s.length; ++i) {
    // get the ascii code
    let num: number = s.charCodeAt(i)

    // for each bit, push an element on the return array
    for (let j = 0; j < 8; ++j) {
      ret.push((num >> j) & 1)
    }
  }

  return ret
}

// convert an array produced by a Decoder to a string
export function binaryArrayToString(bits: number[]): string {

  const nums: number[] = []
  // group array into arrays of 8 bits
  for(let i = 0; i < bits.length; i+=8) {
    let num: number = 0
    // reconstruct the ascii code from the bits
    for (let j = 0; j < 8 && j + i < bits.length; ++j) {
      num |= (bits[j + i] << j)
    }
    nums.push(num)
  }

  return String.fromCharCode(...nums)
}

// convert an array of bits into a number
// use intuitive ordering, so [ 1, 0 ] -> 2
export function arrayToNumber(bits: number[]): number {
  let num: number = 0
  for (let i: number = bits.length-1; i >= 0; --i) {
    num |= bits[i] << i
  }
  return num
}

// convert a number into an array of bits of specified length
// preserve intuitive ordering, so 2 -> [ 1, 0 ]
export function numberToArray(num: number, len:number): number[] {
  let bits: number[] = []
  for (let i: number = 0; i < len; ++i) {
    bits.unshift((num >> i) & 1)
  }
  return bits
}


// A simple convolutional encoder
export class Encoder {

  // input parameters
  n: number = 3             // number of bits per output symbol
  K: number = 3             // constraint length
  gen: number[][] = []      // n binary generator polynomials of length K
  input: number[] = []      // string of input bits

  // current state
  i: number = -1            // the next output symbol will be the ith one
  reg: number[] = []        // K single bit shift registers

  // history
  states: number[][] = []   // stored states
  outputs: number[][] = []  // stored outputs
  finished: boolean = false

  constructor(n: number, K: number, gen: number[][], input: number[]) {
    this.n = n
    this.K = K
    this.gen = gen
    this.input = input
    this.reset()
  }

  // reset to initial state
  reset() {
    this.i = -1
    this.finished = false
    this.reg = new Array<number>(this.K).fill(0)
    this.states = new Array<number[]>()
    this.states.push(Array.from(this.reg))
    this.outputs = new Array<number[]>()
    this.next()
  }

  // produce a simple example encoder
  static example(input: number[] = [1,0,1,1,0,0,0,1]) {
    return new Encoder(2, 3, [[1,1,1], [1,0,1]], input)
  }

  // call next() until input encoded, flatten outputs and return as number[]
  encodeAndFlatten(): number[] {
    while(this.next());
    return this.outputs.reduce((acc, curr) => acc.concat(curr), [])
  }

  // retrieve next output symbol and return it
  next() {

    if (this.finished) {
      return undefined
    }

    this.i++

    //console.log(this.reg)

    // update shift registers
    this.reg.pop()
    this.reg.unshift(this.input[this.i])

    // output will be an array of bits
    const out_symbol: number[] = new Array(this.n).fill(0)

    // for each output bit
    for (let j: number = 0; j < this.n; ++j) {
      // use the jth generator polynomial to produce the bit
      out_symbol[j] = this.gen[j].reduce((acc, g, k) => g ? (acc + this.reg[k]) % 2 : acc, 0)
    }

    //console.log("state: "+this.reg)
    //console.log("out: "+out_symbol)

    // bookkeeping
    this.states.push(Array.from(this.reg))
    this.outputs.push(Array.from(out_symbol))

    if (this.i + 1 >= this.input.length) {
      this.finished = true
    }

    return out_symbol
  }

}

// A Viterbi algorithm decoder
export class Decoder {

  // input parameters
  n: number = 3           // number of bits per encoded symbol
  N: number = 4           // number of encoder states
  K: number = 3           // constraint length (polynomial length)
  gen: number[][] = []    // n binary generator polynomials of length K
  input: number[] = []    // string of n-bit symbols generated by the encoder (length should be a multiple of n)

  // state transition graph, indexed by state number
  // in the decoder, the state is just an integer in [0, N)
  // [ { prev: [ number, number ], output: [ number[], number[] ] }, ... ]
  // prev contains the previous possible states in no particular order
  // output contains the binary strings of output for this state indexed by input (0 or 1)
  graph: any[] = []

  // current state
  i: number = -2                // the index of the next encoded symbol in the input array. this.i/this.n = table.length-1
  curr_state: number = 0        // next state to be evaluated (row in the table)
  // (input.length/n) x N table of { hamming: number, prev: number, bit: number }
  // hamming is the culmulative best hamming distance to this node
  // prev is the previous state as just an index
  // bit is the bit that was most likely transitioned on to get to this state
  table: any[][] = []
  finished: boolean = false
  // all most likely decodings if there are multiple with equal probability
  likely_decodings: number[][] = []

  constructor(n: number, K: number, gen: number[][], input: number[]) {
    this.n = n
    this.K = K
    this.N = Math.pow(2, K-1)
    this.gen = gen
    this.input = input
    this.reset()
  }

  reset() {
    this.likely_decodings = []
    this.curr_state = 0
    this.i = 0
    this.finished = false
    this.table = new Array<any[]>()
    // fill first row with impossible states
    this.table.push(new Array<any>(this.N).fill({hamming: Number.MAX_SAFE_INTEGER, prev: -1, bit: -1}))
    // we start in state 0 with 0 accumulated hamming distance
    this.table[0][0] = { hamming: 0, prev: -1, bit: -1 } // note we need a new object here
    // add another empty entry
    this.table.push([])
    // initialise state transition graph
    this.graph = new Array<any>()
    // for each state
    for (let s: number = 0; s < this.N; ++s) {
      // encoder representation of state
      const state: number[] = numberToArray(s, this.K-1)

      this.graph.push({
        // two possible previous states
        prev: [ (s << 1) & ~(1 << this.K-1), ((s << 1) & ~(1 << this.K-1)) + 1 ],
        // two possible outputs, 0 input and 1 input
        output: [ this.get_output(0, state), this.get_output(1, state) ]
      })
    }
  }

  // use generator polynomials to compute output for a given input + state
  // input is 1 or 0
  get_output(input: number, state: number[]) {
    const full_state: number[] = [input, ...state]
    // compute output bits
    const out_symbol: number[] = new Array(this.n).fill(0)
    // for each output bit
    for (let j: number = 0; j < this.n; ++j) {
      // use the jth generator polynomial to produce the bit
      out_symbol[j] = this.gen[j].reduce((acc, g, k) => g ? (acc + full_state[k]) % 2 : acc, 0)
    }
    return out_symbol
  }

  // produce a simple example decoder
  static example(input: number[]) {
    return new Decoder(2, 3, [[1,1,1], [1,0,1]], input)
  }

  // hamming distance between two bit strings of the same length
  // this acts similarly to a likelihood function of observable symbol a being produced by actual symbol b in the presence of bit errors
  hamming(a: number[], b: number[]) {
    return a.reduce((acc, a_i, i) => acc + (a_i ^ b[i]), 0) // add the xor of each bit
  }

  get_prev(s: number): number[] {
    return this.graph[s].prev
  }

  get_prev_bit(s: number): number {
    return s >> this.K-2
  }

  // go back a state ... don't compute anything
  prev_state(): void {
    if (this.finished) {
      this.finished = false
      this.likely_decodings = []
      this.table[this.table.length - 1].pop()
      return
    }
    if (this.curr_state - 1 < 0) {
      // if we're not in the first entry, go back
      if (this.i >= this.n) {
        this.table.pop()
        this.i -= this.n

        this.table[this.table.length - 1].pop()
        this.curr_state = this.N - 1
      }
    } else {
      this.table[this.table.length - 1].pop()
      this.curr_state--
    }
  }

  // complete current state. return true if there are more states to do
  next_state(): boolean {

    // return early
    if (this.finished) return false

    // consider the next n bits in the input
    const out_bits: number[] = this.input.slice(this.i,this.i+this.n)

    // for each previous possible state, compute the outputs generated by transitioning to s
    // compare the outputs to out_bits and choose the lowest hamming distance
    const prev: number[] = this.get_prev(this.curr_state)

    // the leftmost bit is the one that was transitioned on to get to this state
    const bit: number = this.get_prev_bit(this.curr_state)

    const hamming_1: number = this.table[this.i/this.n][prev[0]].hamming + this.hamming(out_bits, this.graph[prev[0]].output[bit])
    const hamming_2: number = this.table[this.i/this.n][prev[1]].hamming + this.hamming(out_bits, this.graph[prev[1]].output[bit])

    // console.log(`state ${s} can come from ${prev_1}: ${this.graph[prev_1].output[bit]} or ${prev_2}: ${this.graph[prev_2].output[bit]}`)

    let obj: any = {}

    if (hamming_1 < hamming_2) {
      obj = { hamming: hamming_1, prev: prev[0], bit }
    } else {
      obj = { hamming: hamming_2, prev: prev[1], bit }
    }

    this.table[this.table.length - 1].push(obj)

    if (this.i + this.n >= this.input.length && this.curr_state + 1 >= this.N) {
      this.finished = true
      return false
    }

    // new entry if we've done all states
    if (this.curr_state + 1 >= this.N) {
      this.table.push([])
      this.i += this.n
      this.curr_state = 0
    } else {
      this.curr_state++
    }

    return true
  }

  // complete current symbol. return true if there are more symbols to do
  next_symbol(): boolean {
    // early exit
    if (this.finished) return false

    let ret = true
    const old_i = this.i
    do {
      // always advance at least one state
      ret = this.next_state()
      // continue until next output symbol, or until finished
    } while(old_i == this.i && ret)

    // return whatever next_state returned
    return ret
  }

  // get the path through the filled-in table
  get_path(): number[][] {
    //console.log("table length")
    //console.log(this.table.length)
    //console.log(this.table)

    // find list of equal, minimal hamming distance states from last entry in table
    let min: number = Number.MAX_SAFE_INTEGER
    for (let i: number = 0; i < this.N; ++i) {
      const hamming: number = this.table[this.table.length -1][i].hamming
      min = hamming < min ? hamming : min
    }
    const min_states: number[] = this.table[this.table.length - 1]
      .map(({ hamming }, state) => ({ hamming, state }))
      .filter(curr => curr.hamming == min)
      .map((curr) => curr.state)

    this.likely_decodings = []

    for (let s of min_states) {
      const decoded: number[] = []

      for (let i: number = this.table.length-1; i > 0; --i) {
        decoded[i-1] = this.table[i][s].bit
        s = this.table[i][s].prev
      }
      this.likely_decodings.push(decoded)
    }

    return this.likely_decodings
  }

  // decode the remaining input symbols and return the most likely decoding
  decode(): number[][] {
    // do all steps
    while(this.next_symbol());
    return this.get_path()
  }
}



function testEncoder() {
  const inCode = stringToBinaryArray("Hello, Viterbi!")

  //console.log("in code length")
  //console.log(inCode.length)
  //console.log(inCode)
  const encoder = Encoder.example(inCode)

  // encode the thing, and flatten to a bitstring
  let coded: number[] = []
  let i: number = 0
  for (
    let curr = encoder.next();
    curr !== undefined;
    curr = encoder.next()) {
      i++
      coded = coded.concat(curr)
    }
    //console.log("coded length")
    //console.log(coded.length)

    // some bit-errors
    coded[1] = ~coded[1]
    coded[3] = ~coded[3]
    coded[14] = ~coded[13]
    coded[14] = ~coded[14]
    coded[21] = ~coded[21]
    coded[22] = ~coded[22]
    //coded[23] = ~coded[23] // this will cause an error as

    const decoder = Decoder.example(coded)

  }
