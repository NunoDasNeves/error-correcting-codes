<template>
  <div class="main-content">
    <h3 style="font-family:var(--font-monospace);">Viterbi Algorithm</h3>
    <section>

      <form v-if="!got_params && !decoder_started">
        Type a (short) input string:<br/>
        <AppInput v-model="input_string" :valid="input_string.length <= MAX_INPUT_CHARS" style="width:40px;"/><br/>
        <div v-if="input_string.length > MAX_INPUT_CHARS">
          Please limit the input to {{ MAX_INPUT_CHARS }} characters
        </div>
        <AppButton @click.native="encode_string" :type="'green'">Encode</AppButton>
      </form>

      <form v-else-if="!decoder_started">
        <AppButton :type="'warning'" @click.native="() => { got_params = false; decoder_params.input = [] }">Back</AppButton><br/>
        This is the binary stream generated by the convolutional encoder, broken up into symbols of length <Math>$n$</Math>. Transmission across a noisy medium may introduce errors, which we can simulate here.
        <p></p>
        Click individual bits to flip them, or just add some random error.<br/>
        <InputErrorBits
          :bits="decoder_params.input"
          :n="decoder_params.n"
          :errors="errors"
          :callback="toggle_error"
          :flip="true"
          />
          <AppButton @click.native="() => errors = {}">Clear</AppButton>
          <AppButton @click.native="randomize_errors">Random</AppButton>
          <br/>
        <AppButton @click.native="start_decoder" :type="'green'">Start Decoding</AppButton>
      </form>

      <div v-else>
        <AppButton :type="'warning'" @click.native="stop_decoder">Back</AppButton>
        <AppButton :type="'warning'" @click.native="reset_decoder">Reset</AppButton>
        <br/>
        Input symbols:<br/>
        <InputErrorBits
          :bits="decoder_params.input"
          :n="decoder_params.n"
          :errors="errors"
          :callback="() => ({})"
          :flip="false"
          :curr_symbol="decoder.i/decoder.n"
          />

        <AppSpoiler :title="'Trellis Diagram'"><TrellisDiagramInfo/></AppSpoiler>

        <TrellisDiagram :decoder="decoder"/>

        <AppButton :disabled="decoder.i == 0 && decoder.curr_state == 0" @click.native="decoder.prev_state">< Previous State</AppButton>
        <AppButton :disabled="decoder.finished" @click.native="decoder.next_state">Next State ></AppButton>
        <AppButton :disabled="decoder.finished" @click.native="decoder.next_symbol">Next Symbol >></AppButton>

        <p></p>

        The output of the decoder is the most likely sequence of bits to have caused the sequence of symbols in the presence of minimal errors.<br/>
        This sequence is traced back through the table, from the minimal hamming distance in the last column.<br/>
        <AppButton @click.native="decoder.decode" :type="'green'">Decode</AppButton>
        <p></p>
        <div v-if="decoded_strings.length == 1">
          The most likely input string is:<br/>
          "{{ decoded_strings[0] }}"
        </div>
        <div v-else-if="decoded_strings.length > 1">
          In this case, due to errors there are multiple equally-likely decodings.<br/>
          They cannot be differentiated based on culmulative Hamming distance alone:<br/>
          <ul>
            <li v-for="(s, i) in decoded_strings" :key="i">
              "{{ s }}"
            </li>
          </ul>
        </div>

      </div>

    </section>
  </div>
</template>

<script lang="ts">
import { Vue, Component, Prop } from 'vue-property-decorator'
import InputErrorBits from '@/components/Decoder/InputErrorBits.vue'
import TrellisDiagram from '@/components/Decoder/Diagram.vue'
import TrellisDiagramInfo from '@/components/Decoder/DiagramInfo.vue'
import { DecoderParams, DecoderModule } from '@/store/decoder.ts'
import { Encoder, Decoder, stringToBinaryArray, binaryArrayToString } from '@/algorithms/viterbi_encoder_decoder.ts'

@Component({ components: { InputErrorBits, TrellisDiagram, TrellisDiagramInfo }})
export default class ViterbiDecoder extends Vue {
  @Prop({ type: Object, default:()=>null })
  passed_params!: any

  MAX_INPUT_CHARS: number = 4

  got_params: boolean = false
  input_string: string = ''
  errors: any = {}

  decoder_params: DecoderParams = {
      input: [],
      K: 3,
      n: 3,
      gen: [[1,1,1], [0,1,1], [1,0,1]]
  }

  get decoder(): Decoder {
    return DecoderModule.decoder
  }

  get decoder_started(): boolean {
    return DecoderModule.decoder_started
  }

  get decoded_strings(): string[] {
    return this.decoder.likely_decodings.map(binaryArrayToString)
  }

  toggle_error(index: number) {
    this.errors[index] = !this.errors[index]
    this.errors = {...this.errors} // we need to change the reference to make the prop reactive...
  }

  randomize_errors() {
    const error_array: boolean[] = new Array<boolean>(this.decoder_params.input.length).fill(false)
    this.errors = error_array.reduce((acc:any, curr:boolean, i:number) => {
      acc[i] = Boolean(Math.round(Math.random()*2/3))
      return acc
    }, {})
  }

  // flip bits in input corresponding to error map
  apply_errors() {
    Object.keys(this.errors).map((value:string) => {
      if (this.errors[value]) {
        this.decoder_params.input[Number(value)] = Number(!this.decoder_params.input[Number(value)])
      }
    })
  }

  start_decoder() {
    this.apply_errors()
    DecoderModule.start_decoder(this.decoder_params)
  }
  stop_decoder() {
    this.apply_errors()
    DecoderModule.stop_decoder()
  }
  reset_decoder() {
    this.decoder.reset()
  }

  created() {
    // use passed params if they exist
    if (this.passed_params) {
      this.decoder_params = this.passed_params
      this.got_params = true
      DecoderModule.stop_decoder()
    }
  }

  encode_string() {
    const encoder_input: number[] = stringToBinaryArray(this.input_string)
    const encoder: Encoder = new Encoder(this.decoder_params.n, this.decoder_params.K, this.decoder_params.gen, encoder_input)
    this.decoder_params.input = encoder.encodeAndFlatten()
    this.got_params = true
  }

}
</script>

<style scoped lang="less">
</style>
