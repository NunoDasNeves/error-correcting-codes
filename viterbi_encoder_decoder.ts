
// convert a regular string to an array of bits for use with an Encoder
function stringToBinaryArray(s: string) {
    const ret: number[] = []

    for(let i = 0; i < s.length; ++i) {
        // get the ascii code
        let num: number = s.charCodeAt(i)

        // for each bit, push an element on the return array
        for (let j = 0; j < 8; ++j) {
            ret.push((num >> j) & 1)
        }
    }

    return ret
}

// convert an array produced by a Decoder to a string
function binaryArrayToString(bits: number[]) {

    const nums: number[] = []
    // group array into arrays of 8 bits
    for(let i = 0; i < bits.length; i+=8) {
        let num: number = 0
        // reconstruct the ascii code from the bits
        for (let j = 0; j < 8 && j + i < bits.length; ++j) {
            num |= (bits[j + i] << j)
        }
        nums.push(num)
    }

    return String.fromCharCode(...nums)
}


// A simple convolutional encoder
class Encoder {

    // input parameters
    n: number           // number of bits per output symbol
    K: number           // constraint length
    gen: number[][]     // n binary generator polynomials of length K
    input: number[]     // string of input bits

    // current state
    i: number           // the next output symbol will be the ith one
    reg: number[]       // K single bit shift registers

    // history
    states: number[][]  // stored states
    outputs: number[][] // stored outputs

    constructor(n: number, K: number, gen: number[][], input: number[]) {
        this.n = n
        this.K = K
        this.gen = gen
        this.input = input
        this.i = 0
        this.reg = new Array<number>(K).fill(0)
        this.states = new Array<number[]>()
        this.outputs = new Array<number[]>()

        // set up first input bit
        this.reg[0] = input[0]
    }

    // produce a simple example encoder
    static example(input: number[] = [1,0,1,1,0,0,0,1]) {
        return new Encoder(2, 3, [[1,1,1], [1,0,1]], input)
    }

    // retrieve next output symbol and return it
    next() {

        if (this.i > (this.input.length + this.K - 1)) {
            return undefined
        }

        // compute output bits
        const out_symbol: number[] = new Array(this.n).fill(0)
        // for each output bit
        for (let j: number = 0; j < this.n; ++j) {
            // use the jth generator polynomial to produce the bit
            out_symbol[j] = this.gen[j].reduce((acc, g, k) => (acc + this.reg[k]) % 2)
        }

        // bookkeeping
        this.i++
        this.states.push(Array.from(this.reg))
        this.outputs.push(Array.from(out_symbol))

        // update shift registers
        this.reg.pop()
        this.reg.unshift(this.input[this.i] ? this.input[this.i] : 0)

        return out_symbol
    }

}

// A Viterbi algorithm decoder
class Decoder {

    // input parameters
    n: number           // number of bits per output symbol
    N: number           // number of encoder states
    K: number           // constraint length
    gen: number[][]     // n binary generator polynomials of length K
    input: number[][]   // string of n-bit symbols generated by the encoder


    // current state
    i: number           // the next output symbol will be the ith one
    table: number[][]   // K single bit shift registers

    constructor(n: number, K: number, gen: number[][], input: number[][]) {
        this.n = n
        this.K = K
        this.N = Math.pow(2, K-1)
        this.gen = gen
        this.input = input
        this.i = 0
        //this.table = new Array<number[]>().fill(0)
    }

    // produce a simple example decoder
    static example(input: number[] = [1,0,1,1,0,0,0,1]) {
        return new Encoder(2, 3, [[1,1,1], [1,0,1]], input)
    }
}



function testEncoder() {
    const inCode = stringToBinaryArray("hello world")
    console.log(inCode)
    console.log(binaryArrayToString(inCode))

    const e = Encoder.example(inCode)

    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())
    console.log(e.next())

    const d = Decoder.example()
}

testEncoder()

